2d1
< 
12a12,48
> #ifdef _MSC_VER
> 
> #ifdef _M_IX86
> 
> inline uint64_t rdtsc()
> {
>   uint64_t c;
>   __asm {
>     cpuid       // serialize processor
>     rdtsc       // read time stamp counter
>     mov dword ptr [c + 0], eax
>     mov dword ptr [c + 4], edx
>   }
>   return c;
> }
> 
> #elif defined(_M_X64)
> #include <intrin.h>
> 
> #pragma intrinsic(__rdtsc)
> inline uint64_t rdtsc()
> {
>   return __rdtsc();
> }
> 
> #endif
> 
> #else
> static __inline__ unsigned long long rdtsc(void)
> { 
>   unsigned long lo, hi;
>   __asm__ volatile( "rdtsc" : "=a" (lo), "=d" (hi) );
>   return( lo | ( hi << 32 ) );
> }
> 
> #endif
> 
25c61
< PyObject *decode( unsigned char *s, unsigned char *end) {
---
> PyObject *decode( char *s, char *end) {
37d72
<     DBG printf(" %02x \n", *s);
42,43d76
<     // This is deprecated.  We can't do this trick unless we have separate code points
<     //   for 1 / 2 / 4 byte unicode strings
45,58d77
<     //o = PyUnicode_FromKindAndData(PyUnicode_1BYTE_KIND, s, l);
< 
<     //memcpy( sbuf, s, l );
<     s += l;
<     //return o;
< /*
<     //memcpy( sbuf, s, l );
<     //printf("l is %d\n",l);
<     //PyObject *result = PyUnicode_FromUnicode(NULL, l);
<     PyObject *result = PyUnicode_New(l,127);
<     if (! result) { printf("!res\n"); return NULL; }
<     //Py_UNICODE *r = PyUnicode_AS_UNICODE(result);
<     char *r = PyUnicode_1BYTE_DATA(result);
<     memcpy(r, s, l);
60,66d78
<     return result;
<     //return PyUnicode_FromStringAndSize( sbuf, l );
<     //PyUnicode_READY(result);
<     //printf("str: >%.*s<\n", l, s );
<     //printf("str: >%.*s<\n", l, r );
<     //PyObject_Print(result, stdout, 0); printf("\n");
< */
73d84
<     //o = PyUnicode_FromKindAndData(PyUnicode_1BYTE_KIND, s, l);
76,91d86
<     //return o;
< /*
<     if ( l > sbuf_len ) { 
<       while ( l > sbuf_len ) { sbuf_len <<= 1; } 
<       sbuf = (char*)realloc(sbuf, sbuf_len);
<     }
<     memcpy( sbuf, s, l );
<     s += l;
<     return PyUnicode_FromStringAndSize( sbuf, l );
<     PyObject *result = PyUnicode_New(l,127);
<     if (! result) { printf("!res\n"); return NULL; }
<     char *r = PyUnicode_1BYTE_DATA(result);
<     memcpy(r, s, l);
<     s += l;
<     return result;
< */
107c102
<     o = PyLong_FromLong(*p);
---
>     o = PyLong_FromLongLong(*p);
113c108
<     o = PyLong_FromUnsignedLong(*p);
---
>     o = PyLong_FromUnsignedLongLong(*p);
162a158
>     //printf("new dict of len %d\n", l);
206d201
<     //Py_DECREF(o);
217,219d211
<       //printf("depth %d\n",depth);
<       //printf("Key: "); PyObject_Print( keys[depth], stdout, 0 ); printf("\n");
<       //printf("Obj: "); PyObject_Print( o, stdout, 0 ); printf("\n");
235,241d226
< PyObject* unpackc( unsigned char *p, int len ) {
<   return decode( p, p+len );
< }
< void initmrpacker(void) {
< }
< 
< 
255c240
<   unsigned char* p;
---
>   char *p;
262a248,251
>   //unsigned long long cycles = rdtsc();
>   //PyObject *ret = decode( p, p+l );
>   //printf(" took %lld\n", rdtsc() - cycles);
>   //return ret;
